<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构</title>
    <url>/2021/12/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><hr>
<h3 id="1-1-什么是数据结构"><a href="#1-1-什么是数据结构" class="headerlink" title="1.1 什么是数据结构"></a>1.1 什么是数据结构</h3><hr>
<blockquote>
<p>数据结构是一门研究非数值计算的程序设计问题中计算机的操作<strong>对象</strong>以及它们之间的<strong>关系和操作</strong>等等的学科。</p>
</blockquote>
<p><strong>程序设计的实质</strong>是对实际问题选择一个好的数据结构，加之设计一个好的算法。而好的算法在很大程度上取决于描述实际问题的数据结构。          </p>
<p><code>程序 == 算法 + 数据结构</code>  </p>
<span id="more"></span>

<h3 id="1-2-基本概念和术语"><a href="#1-2-基本概念和术语" class="headerlink" title="1.2 基本概念和术语"></a>1.2 基本概念和术语</h3><hr>
<blockquote>
<ul>
<li><strong>数据</strong>：被计算机加工处理的对象。</li>
<li><strong>数据元素（记录、表目）</strong>：数据的基本单位，是数据集合中的一个个体。</li>
<li><strong>数据项</strong>：若干数据项组成一个数据元素。</li>
<li><strong>数据对象</strong>：是性质相同的数据元素的集合，是数据的一个子集。</li>
</ul>
</blockquote>
<p><img src="https://api2.mubu.com/v3/document_image/0205cba1-f315-4876-9611-dd0c4db4fbe6-15633121.jpg" alt="图片"></p>
<blockquote>
<ul>
<li><strong>数据类型</strong>：在一种程序设计语言中，变量所具有的数据种类。</li>
<li><strong>数据结构</strong>：具有结构的数据元素的集合。它包括数据元素的<strong>逻辑结构</strong>、<strong>存储结构</strong>和相适应的运算。<blockquote>
<ol>
<li><strong>逻辑结构</strong>：数据元素之间的逻辑关系，与计算机无关。<blockquote>
<p>(1) <strong>集合结构</strong>：数据元素除了“属于同一集合”的联系之外，没有其它的关系。<br>(2) <strong>线性结构</strong>：数据元素之间存在一对一的关系。<br>(3) <strong>树型结构</strong>：数据元素之间存在一对多的关系。<br>(4) <strong>图状结构</strong>或<strong>网状结构</strong>：数据元素之间存在多对多的关系。</p>
</blockquote>
</li>
<li><strong>存储结构</strong>（物理结构）：指数据的逻辑结构在计算机存储器中的<strong>映象</strong>表示。<blockquote>
<p>(1) <strong>顺序存储</strong>：数据元素依次放在连续的存储单元中。<br>(2) <strong>链式存储</strong>：在存储结点中增加若干指针域，记录后继或者相关结点的地址（指针）。<br>(3) <strong>索引存储</strong>：将数据元素分为若干子表，子表的开始位置存放在索引表中。<br>(4) <strong>散列存储</strong>：根据数据元素的关键字值，由散列函数计算出存储地址。LOC(ai)=H(key)</p>
</blockquote>
</li>
</ol>
<ul>
<li><strong>数据元素的映像</strong>：用二进制位(bit)的位串表示数据元素。每个<strong>数据元素</strong>的映象称为<strong>结点</strong>，每个<strong>数据项</strong>的映象称为<strong>数据域</strong>。</li>
<li><strong>关系的映像</strong>：<blockquote>
<p>顺序映象：以相对的存储位置表示关系<br>链式映象：以附加信息(指针)表示关系</p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
<li><strong>运算</strong>：在数据逻辑结构上定义的一组数据被使用的方式，其具体实现要在存储结构上进行。<blockquote>
<p>常见的运算：<br>(1)建立数据结构              (6)检索*<br>(2)清除数据结构              (7)更新<br>(3)插入数据元素              (8)判空和判满*<br>(4)删除数据元素              (9)求长*<br>(5)排序<br>*操作为<strong>引用型操作</strong>，即数据值不发生变化；其它为<strong>加工型操作</strong>。  </p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="1-3-抽象数据类型的表示与实现"><a href="#1-3-抽象数据类型的表示与实现" class="headerlink" title="1.3 抽象数据类型的表示与实现"></a>1.3 抽象数据类型的表示与实现</h3><hr>
<blockquote>
<p><strong>抽象数据类型 ADT</strong>（ Abstract Data Type ）：数据类型概念的引伸。指一个数学模型以及在其上定义的操作集合，与计算机无关。</p>
<ul>
<li>抽象数据类型的描述方法：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line">数据对象：〈数据对象的定义〉</span><br><span class="line">数据关系：〈数据关系的定义〉</span><br><span class="line">基本操作：〈基本操作的定义〉</span><br><span class="line">&#125; ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>
其中基本操作的定义格式为:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本操作名（参数表）</span><br><span class="line">初始条件：〈初始条件描述〉</span><br><span class="line">操作结果：〈操作结果描述〉</span><br></pre></td></tr></table></figure></li>
<li><strong>赋值参数</strong>：只为操作提供输入值。</li>
<li><strong>引用参数</strong>：除可提供输入值外，还将返回该参数值在操作后的变化结果</li>
<li><strong>初始条件</strong>：描述了操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。</li>
<li><strong>操作结果</strong>：说明了操作正常完成之后，数据结构的变化状况和应返回的结果。</li>
</ul>
</blockquote>
<h3 id="1-4-算法和算法分析："><a href="#1-4-算法和算法分析：" class="headerlink" title="1.4 算法和算法分析："></a>1.4 算法和算法分析：</h3><hr>
<h5 id="1-4-1-算法"><a href="#1-4-1-算法" class="headerlink" title="1.4.1  算法"></a>1.4.1  算法</h5><blockquote>
<p><strong>算法</strong>：是对特定问题求解步骤的一种描述。<br>算法是指令的有限序列，其中每一条指令表示一个或多个操作。</p>
<blockquote>
<ol>
<li><strong>有穷性</strong>：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成。</li>
<li><strong>确定性</strong>：算法中每一条指令必须有确切的含义。不存在二义性。且算法只有一个入口和一个出口。</li>
<li><strong>可行性</strong>：一个算法是可行的。即算法描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。</li>
<li><strong>输入</strong>：一个算法有零个或多个输入，这些输入取自于某个特定的对象集合。</li>
<li><strong>输出</strong>：一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量。</li>
</ol>
</blockquote>
</blockquote>
<h5 id="1-4-2-算法设计的要求"><a href="#1-4-2-算法设计的要求" class="headerlink" title="1.4.2  算法设计的要求"></a>1.4.2  算法设计的要求</h5><p>评价一个好的算法有以下几个标准:</p>
<blockquote>
<ol>
<li><strong>正确性</strong>(Correctness)：算法应满足具体问题的需求。</li>
<li><strong>可读性</strong>(Readability)：算法应该好读。以有利于阅读者对程序的理解。</li>
<li><strong>健状性</strong>(Robustness)：算法应具有容错处理。当输入非法数据时，算法应对其作出反应，而不是产年莫名其妙的输出结果。</li>
<li><strong>效率与存储量需求</strong>：效率指的是算法执行的时间；存储量需求指算法执行过程中所需要的最大存储空间。一般，这两者与问题的规模有关。</li>
</ol>
</blockquote>
<h5 id="1-4-3-算法效率的度量"><a href="#1-4-3-算法效率的度量" class="headerlink" title="1.4.3  算法效率的度量"></a>1.4.3  算法效率的度量</h5><p>算法执行时间需通过依据该算法编制的程序在计算机上运行所消耗的时间来度量。</p>
<blockquote>
<p>一个算法的评价主要从<strong>时间复杂度</strong>和<strong>空间复杂度</strong>来考虑。<br>T(n)表示语句执行的操作数，而O(<em>f(n)</em>)是其同量级函数，一般用后者代表时间复杂度。</p>
</blockquote>
<h5 id="1-4-4-算法的存储空间的需求"><a href="#1-4-4-算法的存储空间的需求" class="headerlink" title="1.4.4  算法的存储空间的需求"></a>1.4.4  算法的存储空间的需求</h5><blockquote>
<p><strong>空间复杂度</strong>：算法所需存储空间的度量，<br>记作<code>S(n)=O(f(n))</code>，其中n为问题的规模(或大小)      </p>
</blockquote>
<p>算法的存储空间：</p>
<blockquote>
<p>(1) 输入数据所占空间；<br>(2) 程序本身所占空间；<br>(3) 辅助变量所占空间。</p>
</blockquote>
<p>可分为：</p>
<blockquote>
<p>(1) 固定部分：程序代码，常量，简单变量，定长的结构变量；<br>(2) 可变部分：与问题规模有关的存储空间。</p>
</blockquote>
<h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><hr>
<p>待完善</p>
<h1 id="第三章：栈与队列"><a href="#第三章：栈与队列" class="headerlink" title="第三章：栈与队列"></a>第三章：栈与队列</h1><hr>
<p>待完善</p>
<h1 id="第四章：串"><a href="#第四章：串" class="headerlink" title="第四章：串"></a>第四章：串</h1><hr>
<h3 id="4-1-串的概念和基本操作"><a href="#4-1-串的概念和基本操作" class="headerlink" title="4.1 串的概念和基本操作"></a>4.1 串的概念和基本操作</h3><hr>
<h5 id="4-1-1-串的概念"><a href="#4-1-1-串的概念" class="headerlink" title="4.1.1 串的概念"></a>4.1.1 串的概念</h5><p><strong>基本术语</strong></p>
<blockquote>
<ul>
<li><strong>串（字符串）</strong>：由零个或多个字符组成的有限序列。    记作：s = ‘a1a2…an’（n&gt;0）。串是特殊的线性表，数据元素是单个字符。  </li>
<li><strong>子串</strong>：串中任意个连续的字符组成的子序列。</li>
<li><strong>主串</strong>：包含了字串的串。</li>
<li><strong>串相等</strong>：两个串长度相等，且对应位置的字符都相等。</li>
<li><strong>空串</strong>：不包含任何字符的串,表示为Φ。</li>
<li><strong>空白串</strong>：由一个或多个空格组成的串，如‘   ’。</li>
<li><strong>子串的位置</strong>：子串的第一个字符在主串中的序号。  </li>
</ul>
</blockquote>
<h5 id="4-1-2-串的基本操作"><a href="#4-1-2-串的基本操作" class="headerlink" title="4.1.2 串的基本操作"></a>4.1.2 串的基本操作</h5><p>待完善</p>
<h3 id="4-2-串的储存结构"><a href="#4-2-串的储存结构" class="headerlink" title="4.2 串的储存结构"></a>4.2 串的储存结构</h3><hr>
<p>待完善</p>
<h3 id="4-3-串的基本操作的实现"><a href="#4-3-串的基本操作的实现" class="headerlink" title="4.3 串的基本操作的实现"></a>4.3 串的基本操作的实现</h3><hr>
<h5 id="4-3-1-静态结构存储串时的实现示例"><a href="#4-3-1-静态结构存储串时的实现示例" class="headerlink" title="4.3.1 静态结构存储串时的实现示例"></a>4.3.1 静态结构存储串时的实现示例</h5><p>待完善</p>
<h3 id="4-4-串的匹配算法"><a href="#4-4-串的匹配算法" class="headerlink" title="4.4 串的匹配算法"></a>4.4 串的匹配算法</h3><hr>
<h5 id="4-4-1-KMP算法"><a href="#4-4-1-KMP算法" class="headerlink" title="4.4.1 KMP算法"></a>4.4.1 KMP算法</h5><p>从左到右匹配，原理如下：</p>
<p><img src="https://api2.mubu.com/v3/document_image/21932a75-63f7-44f8-9e05-ac7db95e7ac2-15633121.jpg" alt="图片"></p>
<p>KMP算法主体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int Index_KMP(SString S, SString T, int pos)    //其中S为主串，T为模式串</span><br><span class="line">&#123;                                               //pos为主串开始比较位置</span><br><span class="line">    i = pos;   j = 0;     </span><br><span class="line">    while (i &lt;= S.length &amp;&amp; j &lt;= T.length) </span><br><span class="line">    &#123;</span><br><span class="line">        if (j == -1 || S[i] == T[j]) </span><br><span class="line">            ++i;  ++j;      //继续比较后继字符</span><br><span class="line">        else</span><br><span class="line">            j = next[j];    //模式串向右移动，匹配模式串下一个可匹配的位置</span><br><span class="line">    &#125;</span><br><span class="line">    if (j &gt; T.length)</span><br><span class="line">        return  i-T.length; //匹配一旦成功，立即返回主串中对应的第一个字符位置</span><br><span class="line">    else</span><br><span class="line">        return -1;          //匹配失败，返回-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可知需求得模式串的next数组。当模式串当前字符匹配失败时，通过next数组可跳过冗余比较，找到下一个可匹配的位置。举例：</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">c</td>
<td align="center">a</td>
<td align="center">c</td>
<td align="center">a</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>下图体现了next[5]与next[7]的逻辑：</p>
<p><img src="https://api2.mubu.com/v3/document_image/23f1d354-3bd3-4844-a982-504423c5dbb4-15633121.jpg" alt="图片"></p>
<p>求next数组算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void get_nextval(SString &amp;T, int &amp;next[]) </span><br><span class="line">&#123;   </span><br><span class="line">    i = 0;   next[0] = -1;   j = -1; </span><br><span class="line">    while (i &lt; T.length) </span><br><span class="line">    &#123;</span><br><span class="line">        if (j == -1 || T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;  ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，当模式串存在下述情况时：</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">-1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
</tbody></table>
<p>当该串与形如‘aaaabaaaabaaaaab’的主串进行匹配时，会导致多次冗余重复比较，如下图所示，当第一次比较过后，重复进行了四次相同的无用比较：</p>
<p><img src="https://api2.mubu.com/v3/document_image/f489b0e0-fc54-4ed2-bb14-3727f542559f-15633121.jpg" alt="图片"></p>
<p>因此，需对next数组的算法进行改进，当出现跳转后的字符与跳转前相同时，能够跳过该跳转后字符的比较。</p>
<p>改进后的求next数组算法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void get_nextval(SString &amp;T, int &amp;nextval[]) </span><br><span class="line">&#123;   </span><br><span class="line">    i = 0;   next[0] = -1;   j = -1; </span><br><span class="line">    while (i &lt; T.length) </span><br><span class="line">    &#123;</span><br><span class="line">        if (j == -1 || T[i] == T[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;  ++j;</span><br><span class="line">            if (T[i] != T[j])</span><br><span class="line">                next[i] = j;</span><br><span class="line">            else</span><br><span class="line">                next[i] = next[j]; </span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进后的next数组：</p>
<table>
<thead>
<tr>
<th align="center">j</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">模式串</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">next[j]</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
<td align="center">-1</td>
</tr>
</tbody></table>
<p>跳过了重复比较，效率得到极大提高。</p>
<h5 id="4-4-2-BM算法"><a href="#4-4-2-BM算法" class="headerlink" title="4.4.2 BM算法"></a>4.4.2 BM算法</h5><p>待完善</p>
<h1 id="第五章：数组和广义表"><a href="#第五章：数组和广义表" class="headerlink" title="第五章：数组和广义表"></a>第五章：数组和广义表</h1><hr>
<p>待完善</p>
<h1 id="第六章：树和二叉树"><a href="#第六章：树和二叉树" class="headerlink" title="第六章：树和二叉树"></a>第六章：树和二叉树</h1><hr>
<p>待完善</p>
<h1 id="第九章：查找表"><a href="#第九章：查找表" class="headerlink" title="第九章：查找表"></a>第九章：查找表</h1><hr>
<h3 id="9-1-概念和术语"><a href="#9-1-概念和术语" class="headerlink" title="9.1 概念和术语"></a>9.1 概念和术语</h3><hr>
<blockquote>
<ul>
<li> <strong>查找表</strong>：同一类型的记录(数据元素)的集合。</li>
<li><strong>关键字</strong>：记录(数据元素)中的某个数据项的值。<blockquote>
<p><strong>主关键字</strong>：该关键字可以唯一地标识一个记录。<br><strong>次关键字</strong>：该关键字不能唯一标识一个记录。</p>
</blockquote>
</li>
<li><strong>查找</strong>：指定某个值，在查找表中确定是否存在一个记录，该记录的关键字等于给定值。</li>
<li><strong>静态查找表</strong>：对查找表的查找仅是以查询为目的，不改动查找表中的数据。</li>
<li><strong>动态查找表</strong>：在查找的过程中同时插入不存在的记录，或删除某个已存在的记录。</li>
<li><strong>查找成功</strong>：查找表中存在满足查找条件的记录。</li>
<li><strong>查找不成功</strong>：查找表中不存在满足查找条件的记录。</li>
<li><strong>内查找</strong>：整个查找过程都在内存中进行。</li>
<li><strong>外查找</strong>：在查找过程中需要访问外存。</li>
<li><strong>平均查找长度ASL</strong>（ Average Search Length ）：查找方法时效的度量。<blockquote>
<p>ASL计算方法：$ ASL = \sum\limits_{i=1}^n {p_ic_i} $ 且 $ \sum\limits_{i=1}^n {p_i} = 1 $<br>n：记录的个数<br>pi：查找第i个记录的概率 ( 不特别声明时认为等概率 pi =1/n )<br>ci：找到第i个记录所需的比较次数</p>
</blockquote>
</li>
</ul>
</blockquote>
<h3 id="9-2-静态查找表"><a href="#9-2-静态查找表" class="headerlink" title="9.2 静态查找表"></a>9.2 静态查找表</h3><hr>
<h5 id="9-2-1-顺序表的查找"><a href="#9-2-1-顺序表的查找" class="headerlink" title="9.2.1 顺序表的查找"></a>9.2.1 顺序表的查找</h5><p>$ ASL = \sum\limits_{i=1}^n {p_ic_i} = \frac{n+1}{2} $</p>
<h5 id="9-2-2-有序表的查找"><a href="#9-2-2-有序表的查找" class="headerlink" title="9.2.2 有序表的查找"></a>9.2.2 有序表的查找</h5><p>$ ASL = \frac{1}{n}\sum\limits_{i=1}^h {j*2^{j-1}} = \frac{n+1}{n}\log_2{(n+1)}-1 \approx \log_2(n+1)-1 $<br>其中 $ h = \lfloor \log_2{n} \rfloor + 1 $  </p>
<p>利用<strong>折半查找</strong>加快效率，学习<strong>判定树</strong>的画法。</p>
<h5 id="9-2-3-静态树表的查找"><a href="#9-2-3-静态树表的查找" class="headerlink" title="9.2.3 静态树表的查找"></a>9.2.3 静态树表的查找</h5><p> 1.静态最优查找树</p>
<blockquote>
<p>定义：查找性能最佳的树。<br>性质：带权内路径长度之和PH为最小值。</p>
</blockquote>
<p>2.<strong>静态次优查找树</strong></p>
<blockquote>
<p>优点：PH值近似最小，且比静态最优查找树易于构造，时间开销少<br><strong>构造方法</strong>：通过令每一个非叶子节点左右子树的权重<strong>尽可能相等</strong>来构造。<br>查找性能：比较次数不超过树的深度 $O(\log_2{n})$。<br>查找步骤：设给定的查找值为K，将根节点作为起始节点。</p>
<blockquote>
<p>(1) 若当前指针为NULL，则返回空指针；<br>(2) 若当前指针不为NULL，则将该节点关键字key与K比较：</p>
<blockquote>
<p>若K = key，则返回当前节点指针；<br>若K &gt; key，则将其左孩子作为当前节点，转(1)；<br>若K &lt; key，则将其右孩子作为当前节点，转(2)。</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="9-2-4-索引顺序表的查找"><a href="#9-2-4-索引顺序表的查找" class="headerlink" title="9.2.4 索引顺序表的查找"></a>9.2.4 索引顺序表的查找</h5><p>分块查找步骤：</p>
<blockquote>
<p>(1) 折半或者顺序查找索引表，确定所在块；<br>(2) 在已确定的块中顺序查找/折半查找；</p>
</blockquote>
<p>设b为索引表长度，s为块中记录个数<br>$ ASL = \frac{1}{b}\sum\limits_{i=1}^b{i} + \sum\limits_{j=1}^s{j} = \frac{1}{2}(b+s)+1 = \frac{1}{2}(\frac{n}{s}+s)+1 $<br>可知 $s$ 取 $\sqrt{n}$ 时，$ASL$ 取最小值 $\sqrt{n}+1$。</p>
<h5 id="9-2-5-动态查找表"><a href="#9-2-5-动态查找表" class="headerlink" title="9.2.5 动态查找表"></a>9.2.5 动态查找表</h5><p>待完善</p>
<h1 id="第十章：内部排序"><a href="#第十章：内部排序" class="headerlink" title="第十章：内部排序"></a>第十章：内部排序</h1><hr>
<p>待完善</p>
]]></content>
  </entry>
  <entry>
    <title>哈哈，这下建站了</title>
    <url>/2021/12/05/hello-world/</url>
    <content><![CDATA[<p>但其实什么也没有捏</p>
]]></content>
  </entry>
</search>
